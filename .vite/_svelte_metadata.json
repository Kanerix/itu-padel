{"compilerOptions":{"css":"external","dev":true,"hmr":true},"configFile":"/Users/kasperjonsson/Projects/itu-padel/svelte.config.js","extensions":[".svelte"],"preprocess":[{"name":"vite-preprocess","style":"async ({ attributes, content, filename = '' }) => {\n\t\tconst ext = attributes.lang ? `.${attributes.lang}` : '.css';\n\t\tif (attributes.lang && !isCSSRequest(ext)) return;\n\t\tif (!cssTransform) {\n\t\t\tcssTransform = createCssTransform(style, config).then((t) => (cssTransform = t));\n\t\t}\n\t\tconst transform = await cssTransform;\n\t\tconst suffix = `${lang_sep}${ext}`;\n\t\tconst moduleId = `${filename}${suffix}`;\n\t\tconst { code, map, deps } = await transform(content, moduleId);\n\t\tremoveLangSuffix(map, suffix);\n\t\tmapToRelative(map, filename);\n\t\tconst dependencies = deps ? Array.from(deps).filter((d) => !d.endsWith(suffix)) : undefined;\n\t\treturn {\n\t\t\tcode,\n\t\t\tmap: map ?? undefined,\n\t\t\tdependencies\n\t\t};\n\t}"},{"markup":"async markup({ content, filename }) {\n\t\t\tif (!content.includes('<enhanced:img')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst s = new MagicString(content);\n\t\t\tconst ast = parse(content, { filename, modern: true });\n\n\t\t\t/**\n\t\t\t * Import path to import name\n\t\t\t * e.g. ./foo.png => __IMPORTED_ASSET_0__\n\t\t\t * @type {Map<string, string>}\n\t\t\t */\n\t\t\tconst imports = new Map();\n\n\t\t\t/**\n\t\t\t * @param {import('svelte/compiler').AST.RegularElement} node\n\t\t\t * @param {AST.Text | AST.ExpressionTag} src_attribute\n\t\t\t * @returns {Promise<void>}\n\t\t\t */\n\t\t\tasync function update_element(node, src_attribute) {\n\t\t\t\tif (src_attribute.type === 'ExpressionTag') {\n\t\t\t\t\tconst start =\n\t\t\t\t\t\t'end' in src_attribute.expression\n\t\t\t\t\t\t\t? src_attribute.expression.end\n\t\t\t\t\t\t\t: src_attribute.expression.range?.[0];\n\t\t\t\t\tconst end =\n\t\t\t\t\t\t'start' in src_attribute.expression\n\t\t\t\t\t\t\t? src_attribute.expression.start\n\t\t\t\t\t\t\t: src_attribute.expression.range?.[1];\n\n\t\t\t\t\tif (typeof start !== 'number' || typeof end !== 'number') {\n\t\t\t\t\t\tthrow new Error('ExpressionTag has no range');\n\t\t\t\t\t}\n\t\t\t\t\tconst src_var_name = content.substring(start, end).trim();\n\n\t\t\t\t\ts.update(node.start, node.end, dynamic_img_to_picture(content, node, src_var_name));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst original_url = src_attribute.raw.trim();\n\t\t\t\tlet url = original_url;\n\n\t\t\t\tif (OPTIMIZABLE.test(url)) {\n\t\t\t\t\tconst sizes = get_attr_value(node, 'sizes');\n\t\t\t\t\tconst width = get_attr_value(node, 'width');\n\t\t\t\t\turl += url.includes('?') ? '&' : '?';\n\t\t\t\t\tif (sizes && 'raw' in sizes) {\n\t\t\t\t\t\turl += 'imgSizes=' + encodeURIComponent(sizes.raw) + '&';\n\t\t\t\t\t}\n\t\t\t\t\tif (width && 'raw' in width) {\n\t\t\t\t\t\turl += 'imgWidth=' + encodeURIComponent(width.raw) + '&';\n\t\t\t\t\t}\n\t\t\t\t\turl += 'enhanced';\n\t\t\t\t}\n\n\t\t\t\t// resolves the import so that we can build the entire picture template string and don't\n\t\t\t\t// need any logic blocks\n\t\t\t\tconst resolved_id = (await opts.plugin_context.resolve(url, filename))?.id;\n\t\t\t\tif (!resolved_id) {\n\t\t\t\t\tconst query_index = url.indexOf('?');\n\t\t\t\t\tconst file_path = query_index >= 0 ? url.substring(0, query_index) : url;\n\t\t\t\t\tif (existsSync(path.resolve(opts.vite_config.publicDir, file_path))) {\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Could not locate ${file_path}. Please move it to be located relative to the page in the routes directory or reference it beginning with /static/. See https://vitejs.dev/guide/assets for more details on referencing assets.`\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t`Could not locate ${file_path}. See https://vitejs.dev/guide/assets for more details on referencing assets.`\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\tif (OPTIMIZABLE.test(url)) {\n\t\t\t\t\tlet image = images.get(resolved_id);\n\t\t\t\t\tif (!image) {\n\t\t\t\t\t\timage = await process(resolved_id, opts);\n\t\t\t\t\t\timages.set(resolved_id, image);\n\t\t\t\t\t}\n\t\t\t\t\ts.update(node.start, node.end, img_to_picture(content, node, image));\n\t\t\t\t} else {\n\t\t\t\t\tconst metadata = await sharp(resolved_id).metadata();\n\t\t\t\t\t// this must come after the await so that we don't hand off processing between getting\n\t\t\t\t\t// the imports.size and incrementing the imports.size\n\t\t\t\t\tconst name = imports.get(original_url) || '__IMPORTED_ASSET_' + imports.size + '__';\n\t\t\t\t\tconst new_markup = `<img ${serialize_img_attributes(content, node.attributes, {\n\t\t\t\t\t\tsrc: `{${name}}`,\n\t\t\t\t\t\twidth: metadata.width || 0,\n\t\t\t\t\t\theight: metadata.height || 0\n\t\t\t\t\t})} />`;\n\t\t\t\t\ts.update(node.start, node.end, new_markup);\n\t\t\t\t\timports.set(original_url, name);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/**\n\t\t\t * @type {Array<ReturnType<typeof update_element>>}\n\t\t\t */\n\t\t\tconst pending_ast_updates = [];\n\n\t\t\twalk(\n\t\t\t\t/** @type {import('svelte/compiler').AST.Root} */ (ast),\n\t\t\t\t{},\n\t\t\t\t{\n\t\t\t\t\t_(_, { next }) {\n\t\t\t\t\t\tnext();\n\t\t\t\t\t},\n\t\t\t\t\t/** @param {import('svelte/compiler').AST.RegularElement} node */\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tRegularElement(node, { next }) {\n\t\t\t\t\t\tif ('name' in node && node.name === 'enhanced:img') {\n\t\t\t\t\t\t\t// Compare node tag match\n\t\t\t\t\t\t\tconst src = get_attr_value(node, 'src');\n\n\t\t\t\t\t\t\tif (!src || typeof src === 'boolean') return;\n\n\t\t\t\t\t\t\tpending_ast_updates.push(update_element(node, src));\n\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tawait Promise.all(pending_ast_updates);\n\n\t\t\t// add imports\n\t\t\tlet text = '';\n\t\t\tif (imports.size) {\n\t\t\t\tfor (const [path, import_name] of imports.entries()) {\n\t\t\t\t\ttext += `\\timport ${import_name} from \"${path}\";\\n`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ast.instance) {\n\t\t\t\t// @ts-ignore\n\t\t\t\ts.appendLeft(ast.instance.content.start, text);\n\t\t\t} else {\n\t\t\t\ts.prepend(`<script>${text}</script>\\n`);\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tcode: s.toString(),\n\t\t\t\tmap: s.generateMap()\n\t\t\t};\n\t\t}"}]}